# -*- coding: utf-8 -*-
"""Tarea1PrograAvanzada.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TTYamiPrMxCtDmxDt7x3f53daijbcEoq
"""

import math #para importar formula de combinatoria

class Combinatoria:
  def __init__(self,N,M):
    self.N=N #n√∫mero de filas de la grilla PCB
    self.M=M #n√∫mero de columnas de la grilla PCB

  ""
  def TotalCaminos(self):
    #Metodo de combinatorias para calcular el total de caminos de A hacia B
    return math.comb(self.N+self.M-2,self.M-1)


###Pruebas del c√≥digo#########
N,M=10,8
ClaseCombinatoria= Combinatoria(N,M) #inicializamos la clase
print("Total de caminos:", ClaseCombinatoria.TotalCaminos()) #El metodo de la clase combinatoria

import numpy as np
class Recurrencia:
  def __init__(self,N,M):
    self.N=N #n√∫mero de filas de la grilla PCB
    self.M=M #n√∫merp de columnas de la grilla PCB

  def TotalCaminos(self):
    grilla=np.zeros((self.N,self.M),int)#crea una grilla que se ir√° rellenando con los caminos

    # Inicializar la primera fila y la primera columna con 1 ya que hay un solo camino para llegar ahi
    grilla[:, 0] = 1  # Primera columna
    grilla[0, :] = 1  # Primera fila

    # Llenar la tabla usando la recurrencia grilla[i][j] = grilla[i-1][j] + grilla[i][j-1]
    #donde grilla[i][j] es n√∫mero de caminos posibles para llegar a la celda en la fila i y la columna j
    for i in range(1, self.N):
      for j in range(1, self.M):
        grilla[i][j] = grilla[i-1][j] + grilla[i][j-1]

    # Se retorna el total de caminos para llegar desde A hacia B
    return grilla[self.N-1][self.M-1]

###Pruebas del c√≥digo#########
N,M=10,8
ClaseRecurrencia= Recurrencia(N,M) #inicializamos la clase
print("Total de caminos:", ClaseRecurrencia.TotalCaminos()) #El metodo de la clase recurrencia

import math
import numpy as np
import time


def calcularTiempo(funcion):

    def funcionMofificada(n):
        inicio = time.time()
        funcion(n)
        final= time.time()
        print(f"Tiempo de ejecuci√≥n: {final - inicio} segundos")
    return funcionMofificada


class Caminos:
    def __init__(self, N, M):
        self.N = N  # n√∫mero de filas de la grilla PCB
        self.M = M  # n√∫mero de columnas de la grilla PCB

    # Primer M√©todo combinatoria
    @calcularTiempo
    def TotalCaminosCombinatoria(self):
        return math.comb(self.N + self.M - 2, self.M - 1)

    # Segundo M√©todo recurrencia
    @calcularTiempo
    def TotalCaminosRecurrencia(self):
        grilla = np.zeros((self.N, self.M), int)  # Crea la grilla

        # Inicializa la primera fila y columna
        grilla[:, 0] = 1  # Primera columna
        grilla[0, :] = 1  # Primera fila

        # Llenar la tabla usando la recurrencia grilla[i][j] = grilla[i-1][j] + grilla[i][j-1]
        #donde grilla[i][j] es n√∫mero de caminos posibles para llegar a la celda en la fila i y la columna j
        for i in range(1, self.N):
            for j in range(1, self.M):
                grilla[i][j] = grilla[i-1][j] + grilla[i][j-1]

        # Se retorna el total de caminos para llegar desde A hacia B
        return grilla[self.N - 1][self.M - 1]

### Pruebas del c√≥digo ###
N, M = 10, 8
ClaseCaminos = Caminos(N, M)#inicializamos la clase

# Llamamos a los m√©todos
print("Total de caminos (Combinatoria):", ClaseCaminos.TotalCaminosCombinatoria())#M√©todo clase combinatoria
print("Total de caminos (Recurrencia):", ClaseCaminos.TotalCaminosRecurrencia())#M√©todo clase recurrencia

import math
import numpy as np
import time

# Decorador para medir el tiempo de ejecuci√≥n
def calcularTiempo(funcion):

    def funcionMofificada(*args, **kwargs):
        inicio = time.time()
        resultado = funcion(*args, **kwargs)
        final = time.time()
        print(f"Tiempo de ejecuci√≥n: {final - inicio} segundos")
        return resultado  # Retorna el resultado calculado
    return funcionMofificada

class Caminos:
    def __init__(self, N, M):
        self.N = N  # n√∫mero de filas de la grilla PCB
        self.M = M  # n√∫mero de columnas de la grilla PCB

    # Primer M√©todo combinatoria
    @calcularTiempo
    def TotalCaminosCombinatoria(self):
        return math.comb(self.N + self.M - 2, self.M - 1)

    # Segundo M√©todo recurrencia
    @calcularTiempo
    def TotalCaminosRecurrencia(self):
        grilla = np.zeros((self.N, self.M), int)  # Crea la grilla

        # Inicializa la primera fila y columna
        grilla[:, 0] = 1  # Primera columna
        grilla[0, :] = 1  # Primera fila

        # Llena la tabla usando la recurrencia
        for i in range(1, self.N):
            for j in range(1, self.M):
                grilla[i][j] = grilla[i-1][j] + grilla[i][j-1]

        return grilla[self.N - 1][self.M - 1]

    def TotalCaminosMetodo(self,metodo):
        if metodo == "combinatoria":
            return self.TotalCaminosCombinatoria()
        elif metodo == "recurrencia":
            return self.TotalCaminosRecurrencia()

### Pruebas del c√≥digo ###
N, M = 10, 8
ClaseCaminos = Caminos(N, M)  # Inicializamos la clase

# Llamadas a los m√©todos
print("Total de caminos (Combinatoria):", ClaseCaminos.TotalCaminosMetodo("combinatoria"))
print("Total de caminos (Recurrencia):", ClaseCaminos.TotalCaminosMetodo("recurrencia"))

import math
import numpy as np
import time
import matplotlib.pyplot as plt

# Decorador para medir el tiempo de ejecuci√≥n
def calcularTiempo(funcion):
    def funcionModificada(*args, **kwargs):
        inicio = time.time()
        resultado = funcion(*args, **kwargs)
        final = time.time()
        return final - inicio, resultado  # Retorna el tiempo y el resultado
    return funcionModificada

class Caminos:
    def __init__(self, N, M):
        self.N = N  # n√∫mero de filas de la grilla PCB
        self.M = M  # n√∫mero de columnas de la grilla PCB

    # Primer M√©todo combinatoria
    @calcularTiempo
    def TotalCaminosCombinatoria(self):
        return math.comb(self.N + self.M - 2, self.M - 1)

    # Segundo M√©todo recurrencia
    @calcularTiempo
    def TotalCaminosRecurrencia(self):
        grilla = np.zeros((self.N, self.M), int)  # Crea la grilla

        # Inicializa la primera fila y columna
        grilla[:, 0] = 1  # Primera columna
        grilla[0, :] = 1  # Primera fila

        # Llena la tabla usando la recurrencia
        for i in range(1, self.N):
            for j in range(1, self.M):
                grilla[i][j] = grilla[i-1][j] + grilla[i][j-1]

        return grilla[self.N - 1][self.M - 1]

    #Para hacer m√°s dinamico la llamada a los distintos m√©todos
    def Metodo(self, metodo):
        if metodo == "combinatoria":
            tiempo, _ = self.TotalCaminosCombinatoria()
        elif metodo == "recurrencia":
            tiempo, _ = self.TotalCaminosRecurrencia()
        return tiempo

### Generar los gr√°ficos ###
def generar_grafico_tiempos():
    tamanos_grilla = [(5, 5), (10, 10), (15, 15), (20, 20), (25, 25)]
    tiempos_combinatoria = []
    tiempos_recurrencia = []

    for N, M in tamanos_grilla:
        ClaseCaminos = Caminos(N, M)
        tiempo_combinatoria = ClaseCaminos.Metodo("combinatoria")
        tiempo_recurrencia = ClaseCaminos.Metodo("recurrencia")
        tiempos_combinatoria.append(tiempo_combinatoria)
        tiempos_recurrencia.append(tiempo_recurrencia)

    # Crear el gr√°fico
    tamanos = [N for N, M in tamanos_grilla]
    plt.plot(tamanos, tiempos_combinatoria, label="Combinatoria", marker="o")
    plt.plot(tamanos, tiempos_recurrencia, label="Recurrencia", marker="x")

    # T√≠tulo y etiquetas
    plt.title("Comparaci√≥n de Tiempos de Ejecuci√≥n")
    plt.xlabel("Tama√±o de la Grilla (NxM)")
    plt.ylabel("Tiempo de Ejecuci√≥n (segundos)")
    plt.legend()

    # Guardar el gr√°fico en formato SVG
    plt.savefig("grafico_tiempos.svg")
    print("Gr√°fico guardado como 'grafico_tiempos.svg'")

    # Mostrar el gr√°fico
    plt.show()

### Ejecutar la generaci√≥n del gr√°fico ###
generar_grafico_tiempos()

"""Preguntas

‚Ä¢ ¬øQu√© es un paradigma de programaci√≥n?

Un paradigma de programaci√≥n es una manera o estilo de programaci√≥n de software. Existen diferentes formas de dise√±ar un lenguaje de programaci√≥n y varios modos de trabajar para obtener los resultados que necesitan los programadores.  Se trata de un conjunto de m√©todos sistem√°ticos aplicables en todos los niveles del dise√±o de programas para resolver problemas computacionales.

Los lenguajes de programaci√≥n adoptan uno o varios paradigmas en funci√≥n del tipo de √≥rdenes que permiten implementar como, por ejemplo, Python o JavaScript, que son multiparadigmas.

¬øEn qu√© se basa la programaci√≥n orientada a objetos?

La programaci√≥n orientada a objetos se basa en el concepto de crear un modelo del problema de destino en sus programas. La programaci√≥n orientada a objetos disminuye los errores y promociona la reutilizaci√≥n del c√≥digo. Python es un lenguaje orientado a objetos. Los objetos definidos en Python tienen las caracter√≠sticas siguientes:

Identidad. Cada objeto debe ser distinguido y ello debe poder demostrarse mediante pruebas. Las pruebas is e is not existen para este fin.
Estado Cada objeto debe ser capaz de almacenar el estado. Para este fin, existen atributos, tales como variables de instancias y campos.
Comportamiento. Cada objeto debe ser capaz de manipular su estado. Para este fin existen m√©todos.

explicar la diferencia de rendimiento entre ùëÇ(1) y ùëÇ(ùëõ)

O(1) u orden 1 se refiere al tiempo de ejecuci√≥n del programa que es constante, es decir no depende del tama√±o de la entrada. O(n) u orden n se refiere a que el tiempo de ejecuci√≥n del programa aumenta linealmente con el tama√±o de la entrada. Por tanto la principal diferencia radica en que los algoritmos O(1) son m√°s rapidos y eficientes que los O(n)

¬øC√≥mo se calcula el orden en un programa que funciona por etapas?

Es importante dividir el programa en etapas individuales ya que cada etapa puede tener un orden distinto. Una vez identificados los distintos ordenes de cada etapa del programa tambien es importante considerar  si las etapas se ejecutan secuancialmente una despu√©s de otra donde el orden va a ser el orden predomiante o si hay paralelismo de ejecuci√≥n. La complejidad de esos casos a menudo va a estar dominada por la m√°s costoda, es decir la de mayor orden

¬øC√≥mo se puede determinar la complejidad temporal de un algoritmo recursivo?

Es importante identificar la f√≥rmula de la recurrencia que expresa el tiempo de ejecuci√≥n. Usar teormea del maestro, en donde se compara con la forma general del teorema del maestro y luego se aplica el teorema del maestro con lo que finalmente se puede obtener la complejidad del problema.
"""